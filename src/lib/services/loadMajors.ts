/**
 * Major data loading service
 * Handles loading and caching of major requirements data
 */

import type { Major, MajorCache, MajorInfo, MajorSection, MajorRequirement } from '../types.js';

// Cache for loaded majors
const majorCache: MajorCache = {};

/**
 * Transform a major display name into a URL-friendly ID using standard URL encoding
 * This handles all edge cases and special characters robustly
 * Examples:
 * - "Mathematics BS" -> "Mathematics%20BS"
 * - "Computer Science and Engineering BS" -> "Computer%20Science%20and%20Engineering%20BS"
 * - "Mathematics/Economics BS" -> "Mathematics%2FEconomics%20BS"
 * - "Women's Studies BA" -> "Women's%20Studies%20BA"
 */
export function majorNameToId(majorName: string): string {
	return encodeURIComponent(majorName);
}

/**
 * Transform a major ID back to a display name format
 * Since IDs are now URL-encoded, we just decode them
 */
export function majorIdToDisplayName(majorId: string): string {
	return decodeURIComponent(majorId);
}

/**
 * Get the degree type from a major name
 * Examples: "Mathematics BS" -> "BS", "Music Performance BM" -> "BM"
 */
export function extractDegreeType(majorName: string): string {
	// Look for common degree patterns at the end of the major name
	const patterns = [
		/\b(BS|BA|BM|BFA|BSN)\b$/i,
		/\bBachelor of (Science|Arts|Music|Fine Arts|Science in Nursing)\b$/i,
		/\b(MS|MA|MBA|PhD|EdD|JD|MD)\b$/i
	];
	
	for (const pattern of patterns) {
		const match = majorName.match(pattern);
		if (match) {
			return match[1].toUpperCase();
		}
	}
	
	return 'BA'; // Default to BA if no match
}

/**
 * Load a major by its ID from the static majors directory
 */
export async function loadMajor(majorId: string): Promise<Major | null> {
	// Check cache first
	if (majorCache[majorId]) {
		return majorCache[majorId];
	}

	try {
		// Convert ID back to display name for file lookup
		const displayName = majorIdToDisplayName(majorId);
		
		// Encode the filename for the URL path
		const encodedFileName = encodeURIComponent(displayName);
		
		// Try to load from static file using encoded filename
		const response = await fetch(`/majors/${encodedFileName}.json`);
		
		if (!response.ok) {
			console.warn(`Major file not found: ${displayName}.json (tried: /majors/${encodedFileName}.json)`);
			return null;
		}

		const major: Major = await response.json();
		
		// Validate the major data structure
		if (!validateMajor(major)) {
			console.error(`Invalid major data structure for ${majorId}`, major);
			return null;
		}

		// Cache the result
		majorCache[majorId] = major;
		return major;
	} catch (error) {
		console.error(`Error loading major ${majorId}:`, error);
		return null;
	}
}

/**
 * Get a list of all available majors
 * This could be generated from scanning the majors directory or from an index file
 */
export async function getMajorsList(): Promise<MajorInfo[]> {
	try {
		// Try to load from an index file first
		const response = await fetch('/majors/index.json');
		
		if (response.ok) {
			const indexData = await response.json();
			return indexData.majors || [];
		}

		// Fallback: return known majors if index doesn't exist
		// In production, this could be generated by scanning the majors directory
		return [
			{
				id: majorNameToId('Mathematics BS'),
				name: 'Mathematics BS',
				college: 'College of Letters and Science',
				department: 'Mathematics',
				degreeLevel: 'Undergraduate',
				degreeObjective: 'Bachelor of Science'
			}
		];
	} catch (error) {
		console.error('Error loading majors list:', error);
		return [];
	}
}

/**
 * Load major by display name (convenience function)
 */
export async function loadMajorByName(majorName: string): Promise<Major | null> {
	const majorId = majorNameToId(majorName);
	return loadMajor(majorId);
}

/**
 * Get all course IDs required by a major (flattened from all sections and groups)
 */
export function getAllMajorCourses(major: Major): string[] {
	const courses = new Set<string>();
	
	for (const section of major.sections) {
		collectCoursesFromRequirements(section.requirements, courses);
	}
	
	return Array.from(courses);
}

/**
 * Recursively collect course IDs from requirements (handles nested groups)
 */
function collectCoursesFromRequirements(requirements: MajorRequirement[], courses: Set<string>): void {
	for (const req of requirements) {
		if (req.type === 'course') {
			courses.add(req.courseId);
		} else if (req.type === 'group') {
			collectCoursesFromRequirements(req.options, courses);
		}
	}
}

/**
 * Validate a major data structure against our schema
 */
function validateMajor(major: any): major is Major {
	if (!major || typeof major !== 'object') return false;
	
	// Check required fields from our new interface
	const requiredStringFields = ['name', 'overview', 'college', 'department', 'degreeLevel', 'degreeObjective'];
	for (const field of requiredStringFields) {
		if (typeof major[field] !== 'string' || !major[field].trim()) {
			console.warn(`Major validation failed: missing or invalid ${field}`);
			return false;
		}
	}
	
	// Validate sections array
	if (!Array.isArray(major.sections) || major.sections.length === 0) {
		console.warn('Major validation failed: sections must be a non-empty array');
		return false;
	}
	
	// Validate each section
	for (const section of major.sections) {
		if (!validateSection(section)) return false;
	}
	
	return true;
}

/**
 * Validate a section data structure
 */
function validateSection(section: any): boolean {
	if (!section || typeof section !== 'object') return false;
	
	// Check required fields from our MajorSection interface
	const requiredStringFields = ['id', 'title', 'description'];
	for (const field of requiredStringFields) {
		if (typeof section[field] !== 'string' || !section[field].trim()) {
			console.warn(`Section validation failed: missing or invalid ${field}`);
			return false;
		}
	}
	
	// Validate requirements array
	if (!Array.isArray(section.requirements)) {
		console.warn('Section validation failed: requirements must be an array');
		return false;
	}
	
	// Validate each requirement
	for (const req of section.requirements) {
		if (!validateRequirement(req)) return false;
	}
	
	return true;
}

/**
 * Validate a requirement (can be course or group)
 */
function validateRequirement(req: any): boolean {
	if (!req || typeof req !== 'object') return false;
	
	if (req.type === 'course') {
		// Validate course requirement
		if (typeof req.courseId !== 'string' || !req.courseId.trim()) {
			console.warn('Course requirement validation failed: missing or invalid courseId');
			return false;
		}
		return true;
	} else if (req.type === 'group') {
		// Validate group requirement
		const requiredStringFields = ['title', 'description'];
		for (const field of requiredStringFields) {
			if (typeof req[field] !== 'string' || !req[field].trim()) {
				console.warn(`Group requirement validation failed: missing or invalid ${field}`);
				return false;
			}
		}
		
		if (typeof req.needs !== 'number' || req.needs <= 0) {
			console.warn('Group requirement validation failed: needs must be a positive number');
			return false;
		}
		
		if (!Array.isArray(req.options) || req.options.length === 0) {
			console.warn('Group requirement validation failed: options must be a non-empty array');
			return false;
		}
		
		// Recursively validate options
		for (const option of req.options) {
			if (!validateRequirement(option)) return false;
		}
		
		return true;
	}
	
	console.warn(`Unknown requirement type: ${req.type}`);
	return false;
}

/**
 * Clear the major cache (useful for development/testing)
 */
export function clearMajorCache(): void {
	// Clear all properties from the cache object
	for (const key in majorCache) {
		delete majorCache[key];
	}
}
