# Data Layer Specification: BruinPlan Frontend

## Overview

This document specifies the architecture, data structures, and algorithms for the frontend data layer that powers lazy loading, search, and dependency resolution in BruinPlan. The goal is to efficiently support interactive course and major exploration while minimizing memory usage and network requests.

---

## 1. Data Indexes

### 1.1 Course Index
- **File:** `static/course_index.json`
- **Contents:** Array or dictionary mapping course IDs and titles to subject codes.
- **Purpose:**
  - Fast, in-memory search for course ID or title (autocomplete, lookup).
  - No descriptions or full course data included.
- **Generated by:** Script that scans all `static/courses/*.json` files.

### 1.2 Major Index
- **File:** `static/major_index.json`
- **Contents:** Array or dictionary of major names, schools, and optionally department.
- **Purpose:**
  - Fast, in-memory search for majors (autocomplete, lookup).
- **Generated by:** Script that scans all `static/majors/*.json` files.

---

## 2. Lazy Loading & Caching

### 2.1 Subject Course Files
- **Files:** `static/courses/[SUBJECT].json`
- **Contents:** Array of course objects for a subject.
- **Load Strategy:**
  - Only load a subject file when a course from that subject is needed (e.g., for rendering a major or course tree).
  - Cache loaded files in memory (Svelte store or similar).
  - Track which subject files are loaded to avoid duplicate fetches.

### 2.2 Major Requirement Files
- **Files:** `static/majors/[Major Name].json`
- **Contents:** Full requirements for a major.
- **Load Strategy:**
  - Load on demand when a user selects a major.
  - Parse requirements to determine subject dependencies.

### 2.3 Cache Management
- **Default:** Keep all loaded data in memory (modern browsers can handle 168 subject files).
- **If needed:** Implement LRU or manual cache eviction if memory becomes a concern.
- **Debug, if needed:** Provide a way to clear cache for debugging or power users.

---

## 3. Dependency Resolution

### 3.1 Major Page Rendering
- **Steps:**
  1. User selects a major.
  2. Fetch `static/majors/[Major Name].json`.
  3. Parse requirements to extract all referenced course IDs.
  4. For each course ID, determine its subject code and ensure `static/courses/[SUBJECT].json` is loaded.
  5. Render the major page using loaded course data.

### 3.2 Course Prerequisite Tree
- **Steps:**
  1. User requests to view a course's prerequisite tree.
  2. Ensure the subject file for the course is loaded.
  3. Recursively load subject files for direct prerequisites as needed (only if not already loaded).
  4. Use the in-memory course index for ID/title lookups when full data is not needed.

---

## 4. API Abstraction

All data access should go through a well-defined API layer. The rest of the app should not know about file structure or fetch logic. The API should handle caching and lazy loading. See notes below for mutation, error, and concurrency policies.

### 4.1 Required API Functions

#### Course Index
- `getCourseIndex(): Promise<CourseIndex[]>`
  - Loads and returns the in-memory course index (ID, title, subject code). Resolves immediately if already loaded.
- `searchCourses(query: string): CourseIndex[]`
  - Returns a filtered list of courses matching the query (by ID or title, case-insensitive substring match).
- `getCourseSummaryById(courseId: string): CourseIndex | undefined`
  - Returns the summary (ID, title, subject) for a given course ID from the index.

#### Major Index
- `getMajorIndex(): Promise<MajorIndex[]>`
  - Loads and returns the in-memory major index. Resolves immediately if already loaded.
- `searchMajors(query: string): MajorIndex[]`
  - Returns a filtered list of majors matching the query (by name or school, case-insensitive substring match).
---
#### Course Data
- `getSubjectCourses(subjectCode: string): Promise<Course[]>`
  - Loads and returns all courses for a subject. Resolves immediately if already loaded.
- `getCourseById(courseId: string): Promise<Course | undefined>`
  - Returns the full course object for a given ID, loading the relevant subject file if needed.

#### Major Data
- `getMajorByName(majorName: string): Promise<Major | undefined>`
  - Loads and returns the full major requirements object for a given major name.
## 5. Generation Scripts
#### Dependency/Tree Utilities
- `getCoursePrerequisites(courseId: string): Promise<Course[]>`
  - Returns the full prerequisite tree for a course, loading subject files as needed. (May be recursive.)
- `getMajorDependencies(majorName: string): Promise<string[]>`
  - Returns a list of subject codes required by a major (parsed from requirements).

#### Cache/State Management
- `clearCache(): void`
  - Clears all loaded data from memory (for debugging or memory management).
- `isLoaded(type: 'subject' | 'major' | 'index', key: string): boolean`
  - Returns whether a given subject, major, or index is loaded in memory.
- Scripts should generate `course_index.json` and `major_index.json` from canonical data.
### 4.2 Types
Type definitions will be maintained in `types.ts` alongside other app types.
- `CourseIndex`: `{ id: string, title: string, subject: string }`
- `MajorIndex`: `{ name: string, school: string, department?: string }`
- `Course`: Full course object as in subject files
- `Major`: Full major object as in major files
Indexes should be minimal for fast load and search.
### 4.3 Notes

#### Mutation Policy
- All API functions return references to cached objects. These objects should be treated as read-only by all consumers.

#### Type Definitions
- All type definitions are maintained in `types.ts`.

#### Error Handling
- No error handling is performed by the API except:
  - If a subject area or major does not exist, a 404 error is thrown (or rejected Promise).
  - If a course does not exist, this is NOT a 404 error; the API returns `undefined` (since some course data may be missing, but subject/major data is complete). The frontend must handle missing course data gracefully.

#### Concurrency
- No concurrency or deduplication logic is needed; the app is static and single-threaded for all practical purposes.

#### Prefetching Policy
- No prefetching is performed by the API.

#### Cache Eviction Policy
- No cache eviction is performed; all loaded data remains in memory for the session.

#### Index Generation Format
- Both `course_index.json` and `major_index.json` should be arrays of minimal/boiled-down objects (courses or majors).
- Each array element/object (i.e., major or course) should be on a single line for compactness and clarity.

#### Scripts
- Scripts should be idempotent and run as part of the data build pipeline.

#### Extensibility
- The API should be extensible for future data types (e.g., instructors, GEs).

#### Data Fetching
- All data fetching should be promise-based (async/await friendly).

---

## 6. Error Handling & Edge Cases

- Gracefully handle missing or corrupt data files.
- Fallback to partial data (e.g., show course ID/title if full data is missing).
- Log errors for debugging.

---

## 7. Future Considerations

- Prefetch likely-needed subject files (e.g., on hover or based on user navigation patterns).
- Support for additional indexes (e.g., by instructor, GE category) as needed.
- Monitor memory usage and optimize cache strategy if necessary.

---

## Summary Table

| Functionality                | Data Source                | Load Strategy         |
|------------------------------|----------------------------|----------------------|
| Course search (ID/title)     | course_index.json          | Always in memory     |
| Major search                 | major_index.json           | Always in memory     |
| Major requirements           | majors/[Major].json        | Lazy load on demand  |
| Subject courses              | courses/[SUBJECT].json     | Lazy load on demand  |
| Prerequisite tree expansion  | courses/[SUBJECT].json     | Lazy load as needed  |

---

This spec provides a foundation for a scalable, maintainable, and responsive frontend data layer for BruinPlan.
